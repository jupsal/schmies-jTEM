<body>
<!--  teaser start -->
<p>The <code>riemann</code> project currently contains two public sub-packages: 
<a href="#sec: schottky"><i><font face="Courier">de.jtem.riemann.schottky</font></i></a>
and
<i><font face="Courier">
  <a href="#sec: theta">de.jtem.riemann.theta</a></font></i><font face="Courier">.
  </font></p>
<p> Both packages implement the current state of research in this field. A third 
package concerning algebraic curves and coverings is subject of a major 
refactoring and will be published as soon as possible.</p>
<!--  teaser end -->

<p>This tutorial gives an introduction to the major functionality of these 
packages and closes with an example: <a href="#sec: KP2 Equation">KP2 Equation - 
Shallow Water Waves</a>.</p>
<p></p>
<h2><a name="sec: schottky"></a>de.jtem.riemann.schottky </h2>
<p>This package implements the numerical methods and algorithms presented in 
[<a href="#[Sch05]">Sch05</a>, Chapter 3] 
for the evaluation of certain automorphic functions and forms in the context of 
Schottky uniformization. A classical theorem states that for any Riemann surface <span style="font-family: Monotype Corsiva">R </span>&nbsp;exists a 
Schottky group <i>G</i> such that&nbsp; is conformally equivalent to the quotient
<i>
<font face="Symbol">W/</font>G</i><span style="font-size: 12.0pt; font-family: Times New Roman"><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1025" DrawAspect="Content" ObjectID="_1198865271">
 </o:OLEObject>
</xml><![endif]--></span>, where <i> <font face="Symbol">W</font></i><span style="font-size: 12.0pt; font-family: Times New Roman">
<!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1025" DrawAspect="Content" ObjectID="_1198865323">
 </o:OLEObject>
</xml><![endif]--></span><!--[if gte mso 9]><![endif]-->denotes the set of 
discontinuity of <i>G</i>. A Schottky group is a free, finitely generated, 
discontinuous group that is purely loxodromic, i.e., a Schottky group of rank <i>N</i>, 
which equals the genus of the associated Riemann surface, can always be 
generated by <i>N</i> loxodromic transformations
<!-- MATH
 $\sigma_{1},\ldots,\sigma_{N}$
 --><i><font face="Symbol">s<sub>1</sub>,...,s<sub>N</sub></font>.</i> Further a 
loxodromic transformation
<!-- MATH
 $\sigma_{1},\ldots,\sigma_{N}$
 --><i><font face="Symbol">s</font><font face="Times New Roman"><sub>i</sub></font>
</i>can be defined by its fixed points <i>A<font face="Times New Roman"><sub>i</sub></font></i> 
and <i>B<font face="Times New Roman"><sub>i</sub></font></i> and the loxodromic factor
<i>
<font face="Symbol">m</font><font face="Times New Roman"><sub>i</sub></font></i>, 
with
<!-- MATH
 $\left|\mu_{i}\right|<1$
 --><i>|<font face="Symbol">m</font><font face="Times New Roman"><sub>i</sub></font>|&lt;1</i>.
</p>
<p>Thus all Schottky groups of rank <i>N</i> can be associated to a list of <i>3N</i> complex 
values <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
S=\left\{ A_{1},B_{1},\mu_{1},\ldots,A_{N},B_{N},\mu_{N}\right\} \,,
\end{displaymath}
 -->
  <p><i>S = { A<font face="Symbol"><sub>1</sub></font>, B<sub><font face="Symbol">1</font></sub>,<font face="Symbol"> 
  m<sub>1, ... , </sub></font>A<sub><font face="Symbol">N</font></sub>, B<sub><font face="Symbol">N</font></sub>,<font face="Symbol"> 
  m<sub>N </sub></font>}</i>
</div>
<p>which is called the Schottky data. Not any <i>3N</i> complex numbers define a 
Schottky group, but there exists a convenient sufficient criterion which is 
related to the notion of <i>iso-classical</i> Schottky groups. For any 
loxodromic transformation exists a unique pair of circles having the same radii, 
which are mapped by the transformation onto each other. These circles are called
<i>isometric circles</i>. The differential of the transformation takes on the 
absolute value <i>1</i> one the circle. A Schottky group is called iso-classical if all 
the isometric circles of the generators are exterior to each other. This can be 
easily checked for a set of generators and it is easy to see that such a set 
generates a free, finitely generated, discontinuous group, which is therefore a 
Schottky group. The exterior of the isometric circles of a classical Schottky 
group define a fundamental domain for the quotient <i> <font face="Symbol">W/</font>G</i><span style="font-size: 12.0pt; font-family: Times New Roman"><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1025" DrawAspect="Content" ObjectID="_1198865271">
 </o:OLEObject>
</xml><![endif]--></span>, i.e., it maps conformally one-to-one to the 
associated Riemann surface. It is not clear that all Riemann surfaces can be 
uniformized by a iso-classical Schottky group. Thus, the fact that the numerics 
only deals with iso-classical Schottky groups means a limitation. </p>
<p>The strength of this approach is that functions and differentials of the 
Riemann surface <i> <font face="Symbol">W/</font>G</i><span style="font-size: 12.0pt; font-family: Times New Roman"><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1025" DrawAspect="Content" ObjectID="_1198865271">
 </o:OLEObject>
</xml><![endif]--><!--[if gte mso 9]> <![endif]--></span>&nbsp;must be 
automorphic <i> <font face="Symbol">W</font></i>. For normalized 
differentials of first kind exist closed representations as <i>(-2)-</i>dimensional 
Poincare theta series:
<br>
</p>
<div ALIGN="RIGHT">
  <!-- MATH
 \begin{equation}
\Omega_{n}\left(z\right)=\int_{\infty}^{z}\omega_{n}=\sum_{\sigma\in\GGn}\log\frac{z-\sigma\left(B_{n}\right)}{z-\sigma\left(A_{n}\right)}
\end{equation}
 -->
  <table WIDTH="100%" ALIGN="CENTER">
    <tr VALIGN="MIDDLE">
      <td ALIGN="CENTER" NOWRAP>
      <a NAME="eq:_series_for_differential_of_1st_kind"></a>
      <img border="0" src="doc-files/index.9.gif" width="280" height="47"></td>
      <td WIDTH="10" ALIGN="RIGHT">(2)</td>
    </tr>
  </table>
</div>
<p>where <i>G<sub>n</sub></i> denotes the subgroup of generated by the generator
<i>
<font face="Symbol">s</font><sub>n</sub></i> and <i>G<sub>n</sub>\G</i> defines the cosets. 
Elementary computations deliver further formulas for the integrals of first kind
<br>
</p>
<div ALIGN="RIGHT">
  <!-- MATH
 \begin{equation}
\Omega_{n}\left(z\right)=\int_{\infty}^{z}\omega_{n}=\sum_{\sigma\in\GGn}\log\frac{z-\sigma\left(B_{n}\right)}{z-\sigma\left(A_{n}\right)}
\end{equation}
 -->
  <table WIDTH="100%" ALIGN="CENTER">
    <tr VALIGN="MIDDLE">
      <td ALIGN="CENTER" NOWRAP><a NAME="eq:_integrals_of_1st_kind"></a>
      <img border="0" src="doc-files/index.17.gif" width="212" height="47"></td>
      <td WIDTH="10" ALIGN="RIGHT">(3)</td>
    </tr>
  </table>
</div>
<p>and the period matrix <br>
</p>
<div ALIGN="RIGHT">
  <!-- MATH
 \begin{equation}
B_{nm}=\delta_{nm}\log\mu_{n}+\sum_{\sigma\in\GmGGn,\sigma\neq id}\log\left\{ B_{m},A_{m},\sigma\left(B_{n}\right),\sigma\left(A_{n}\right)\right\} \,,
\end{equation}
 -->
  <table WIDTH="100%" ALIGN="CENTER">
    <tr VALIGN="MIDDLE">
      <td ALIGN="CENTER" NOWRAP><a NAME="eq:_series_for_period_matrix"></a>
      <img border="0" src="doc-files/index.1.gif" width="301" height="36"></td>
      <td WIDTH="10" ALIGN="RIGHT">(4)</td>
    </tr>
  </table>
</div>
<p>where the <i>curly</i> brackets indicate the cross-ratio</p>
<p align="center">&nbsp;<img border="0" src="doc-files/index.2.gif" width="148" height="38">. </p>
<p>The series above do not always converge and it is challenging to evaluate 
them in a stable manner. </p>
<p>The numerics in this package allow the evaluation of several other series:
</p>
<p></p>
<ol>
  <li>Normalized differentials and integrals of third kind having simple poles 
  at A and B with residues 1 and -1: <br>
  <div ALIGN="RIGHT">
    <!-- MATH
 \begin{equation}
\omega\left(z\right)=\sum_{\sigma\in G}\left(\frac{1}{\sigma\left(z\right)-B}-\frac{1}{\sigma\left(z\right)-A}\right)\left(\gamma_{\sigma}z+\delta_{\sigma}\right)^{-2}dz
\end{equation}
 -->
    <table WIDTH="100%" ALIGN="CENTER">
      <tr VALIGN="MIDDLE">
        <td ALIGN="CENTER" NOWRAP>
        <a NAME="eq:_series_for_differential_of_3rd_kind"></a>
        <img border="0" src="doc-files/index.3.gif" width="245" height="44"></td>
        <td WIDTH="10" ALIGN="RIGHT">(5)</td>
      </tr>
    </table>
  </div>
  <p>and <br>
  </p>
  <div ALIGN="RIGHT" style="width: 634; height: 1">
    <!-- MATH
 \begin{equation}
\Omega\left(z\right)=\int_{\infty}^{z}\omega=\sum_{\sigma\in G}\log\frac{z-\sigma\left(B\right)}{z-\sigma\left(A\right)}\,.
\end{equation}
 -->
    <table WIDTH="100%" ALIGN="CENTER">
      <tr VALIGN="MIDDLE">
        <td ALIGN="CENTER" NOWRAP>
        <a NAME="eq:_series_for_integrals_of_3rd_kind"></a>
        <img border="0" src="doc-files/index.4.gif" width="176" height="46"></td>
        <td WIDTH="10" ALIGN="RIGHT">(6)</td>
      </tr>
    </table>
  </div>
  <p></p>
  <p></li>
  <li>Series of the form <br>
  <div ALIGN="RIGHT">
    <!-- MATH
 \begin{equation}
\Sigma_{k}\left(z,w\right)=\sum_{\sigma\in G}\sigma\left(z\right)^{k}-\sigma\left(w\right)^{k}
\end{equation}
 -->
    <table WIDTH="100%" ALIGN="CENTER">
      <tr VALIGN="MIDDLE">
        <td ALIGN="CENTER" NOWRAP><a NAME="eq:_series_sigma"></a>
        <img border="0" src="doc-files/index.5.gif" width="168" height="34"></td>
        <td WIDTH="10" ALIGN="RIGHT">(7)</td>
      </tr>
    </table>
  </div>
  <p></p>
  <p></li>
  <li>The constants given by the series of the form <br>
  <div ALIGN="RIGHT">
    <!-- MATH
 \begin{equation}
V_{n,k}=\sum_{\sigma\in\GnG}\sigma\left(A_{n}\right)^{k}-\sigma\left(B_{n}\right)^{k}
\end{equation}
 -->
    <table WIDTH="100%" ALIGN="CENTER">
      <tr VALIGN="MIDDLE">
        <td ALIGN="CENTER" NOWRAP><a NAME="eq:_series_for_vector_V"></a>
        <img border="0" src="doc-files/index.6.gif" width="186" height="37"></td>
        <td WIDTH="10" ALIGN="RIGHT">(8)</td>
      </tr>
    </table>
  </div>
  <p></p>
  <p></li>
  <li>The constant <br>
  <div ALIGN="RIGHT">
    <!-- MATH
 \begin{equation}
\gamma=\sum_{\sigma\in G}\frac{1}{\gamma_{\sigma}^{2}}
\end{equation}
 -->
    <table WIDTH="100%" ALIGN="CENTER">
      <tr VALIGN="MIDDLE">
        <td ALIGN="CENTER" NOWRAP><a NAME="eq:_series_for_gamma"></a>
        <img border="0" src="doc-files/index.7.gif" width="66" height="42"></td>
        <td WIDTH="10" ALIGN="RIGHT">(9)</td>
      </tr>
    </table>
  </div>
  <p></li>
</ol>
<p>The major drawback of this method is that the series above, which we will 
simply refer to as <i>Schottky series</i>, do not converge in the general case 
and that there is no general criteria in sight. However, for many special cases 
criteria exist. </p>
<p>In [<a href="#[Sch05]">Sch05</a>, Chapter 3] sufficient criteria are 
presented that can be easily evaluated by a computer. The 
(integral) series (<a href="#eq:_integrals_of_1st_kind">3</a>), (<a href="#eq:_series_for_period_matrix">4</a>), 
(<a href="#eq:_series_for_integrals_of_3rd_kind">6</a>), (<a href="#eq:_series_sigma">7</a>), 
and (<a href="file:///H:/dr/documents/dr.jtem/jtemBook.bak/jtemBook.html#eq:_series_for_vector_V">8</a>) 
converge if the limit <i>
<!-- MATH
 $q_{\infty}^{\Omega}$
 -->q<font face="Symbol"><sup>W</sup><sub>�</sub></font>&nbsp;</i> of the 
monotonously decreasing series
<!-- MATH
 $q_{\infty}^{\Omega}$
 --><i>q<sup><font face="Symbol">W</font></sup></i><sub><i>k</i> </sub>&nbsp;is smaller then 1. 
The (differential) series (<a href="#eq:_series_for_differential_of_1st_kind">2</a>), 
(<a href="#eq:_series_for_differential_of_3rd_kind">5</a>), and (<a href="#eq:_series_for_gamma">9</a>) 
have similar critirea. They converge if the limit of the monotonously decreasing 
series <i>(q<font face="Symbol"><sup>w</sup></font><sub>k</sub> ) </i>is smaller than 
<i>1</i>. 
The computation of <i>(q<sup><font face="Symbol">*</font></sup><sub>k</sub> )</i> 
involves to generate all group elements up to word length <i>l+1</i>. For groups of 
higher order one should therefore choose carefully how many terms of the series 
<i>(q<sup><font face="Symbol">*</font></sup><sub>k</sub> )</i> are used to check the 
criteria. The monotone series <i>(q<sup><font face="Symbol">*</font></sup><sub>k</sub> 
)</i> converge very fast and in our experience, one should give up if the third term 
is still not smaller one. The series can only be evaluated stably, if it 
converges sufficiently fast, which only is the case if the limit is significant 
smaller then one. </p>
<p>The front-end for the evaluation of the Schottky series is provided by the 
class <i>Schottky</i> which extends the class <i>SchottkyData</i>. The main 
purpose of the class <i>SchotttkyData</i> is to provide a nice front end to 
configure Schottky data and to check whether the data generates a classical 
Schottky group. <i>SchottkyData</i> provides a huge variety of methods allowing 
the manipulation of a fixed number of generators. We recommend to create the 
Schottky data using this class and finally passing the data to an instance of 
the evaluation class <i>Schottky</i>. To create the Schottky data <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
S_{-,2}=\left\{ A,-A,\mu,-\overline{A},\overline{A},\mu\right\}
\end{displaymath}
 -->
  <p><img border="0" src="doc-files/index.8.gif" width="157" height="26"></div>
<p>with <i>A, </i> <font face="Symbol"><i>m �</i></font><i><span style="font-family: Monotype Corsiva">C</span></i><font face="Symbol">
</font>&nbsp;for in the Helicoid <i><span style="font-family: Monotype Corsiva">
He</span></i><sub>2 </sub>you can either write
</p>

<blockquote>

<p><tt><i>schottkyData = new SchottkyData( <br>
&nbsp;&nbsp;&nbsp; new Complex[] { A, A.neg(), mu,A.conjugate().neg(), A.conjugate(), mu } )</i></tt> </p>

</blockquote>
<div ALIGN="left">
  
    
      <p>&nbsp;</p>
    
  
</div>
<p>or configure the object sequentially and write </p>
<hr>

  <blockquote>

  <p>
  <tt><font face="Courier New">schottkyData = new SchottkyData( 2 );<br>
  schottkyData.setA(&nbsp;0, A );<br>
  schottkyData.setB(&nbsp;0, A.neg() );<br>
  schottkyData.setMu(&nbsp;0, mu );<br>
  schottkyData.setA(&nbsp;1, A.conjugate().neg() );<br>
  schottkyData.setB(&nbsp;1, A.conjugate() );<br>
  schottkyData.setMu(&nbsp;1, mu );</font></tt></p>

</blockquote>

<hr>
<p></p>


<p><br>
</p>
<p>Before you pass the Schottky data to the evaluator class <tt><i>Schottky</i></tt>, 
you should check whether the data generates a classical schottky group and call
</p>

<blockquote>

<p><tt><i>schottkyData.isClassical()</i></tt>.
</p>

</blockquote>

<p>Otherwise you run the risk of getting a <i>RuntimeException</i> 
when you pass the data to the evaluator, which you can do at its instanciatino:
</p>

<blockquote>

<p><tt><i>schottky = new Schottky( schottkyData );</i></tt> </p>

</blockquote>

<p>or afterwards with </p>

<blockquote>

<p><tt><i>schottky.setUniformizationData( schottkyData )</i></tt>. </p>

</blockquote>

<p>At this moment some precomputation steps are performed including the generation 
of all elements of the Schottky group up to word length <i>2</i>. All other elements 
are computed and stored in a tree the first time they are needed for the 
evaluation of a term. Once elements are added to the tree, they are not removed 
unless the entire instance is destroyed. When the group is changed, i.e., the 
Schottky data changes, the instances for the group elements are merely updated (but 
only on demand). This is crucial for the performance, because the tree can get 
very big. We had examples where we dealt with several hundred thousand group 
elements. The default accuracy for the evaluation of the Schottky series is <i>10<sup>-7</sup></i>, 
which is mutable bean property<a href="#foot1779" name="tex2html41"><sup> </sup>
</a>of 
class <tt><i>Schottky</i></tt>. </p>
<p>Before you start to compute the Schottky series you should assure that the 
implemented algorithms are able to evaluate them. According to the discussion 
above we have different criteria for ``differential'' and ``integral'' series, 
which you can query by calling </p>

<blockquote>

<p><tt><i>schottky.isDifferentialSeriesEvaluable()</i></tt></p>

</blockquote>

<p>and </p>

<blockquote>

<p><tt><i>schottky.isIntegralSeriesEvaluable()</i></tt>. </p>

</blockquote>

<p>The methods checks for <i>q<sup><font face="Symbol">*</font></sup><sub>l</sub> &lt;C</i>, 
with the default values <i>l=2</i> and <i>C=0.5</i>. These default values are also mutable 
properties of the class <tt><i>Schottky</i></tt>, but they should only be 
altered with care (see discussion above). Now you are ready to evaluate the 
Schottky series. </p>
<p>To evaluate the period matrix you can simply write </p>

<blockquote>

<p><tt><i>ComplexMatrix B = schottky.getPeriodMatrix().</i></tt> </p>

</blockquote>

<p>The Abelian differential&nbsp; <i> <font face="Symbol">w</font><sub>n</sub></i><font face="Symbol"><sup>&nbsp;
</sup></font>are nevaluated at the position z in the fundamental domain <i>F</i> by </p>

<blockquote>

<p><tt><i>Complex r = schottky.abelianDifferentialOf1stKind( z, n )</i></tt> </p>

</blockquote>

<p>and the integral of first kind by </p>

<blockquote>

<p><tt><i>Complex r = schottky.abelianIntegralOf1stKind( z, n )</i></tt>. </p>

</blockquote>

<p>Because of performance reasons the code does not check whether the position z is 
valid. If the the argument z is in one of the isometric circles the algorithm 
can fail and the code will throw a <tt><i>RuntimeException</i></tt>, but first 
it will create the maximum number of possible group elements (default: 200,000). 
This is certainly to be avoided; if your are not sure that an argument is valid, 
you should test this with </p>

<blockquote>

<p><tt><i>schottky.isInFundamentalDomain( z )</i></tt>&nbsp; </p>

</blockquote>

<p>in forehand. </p>
<p>All methods for evaluating Schottky series are overwritten with versions that 
allow the prescription of a specific accuracy, e.g. , </p>

<blockquote>

<p><tt><i>ComplexMatrix B = schottky.getPeriodMatrix( 0.001 )</i></tt>
</p>

</blockquote>

<p>evaluates the period matrix with an accuracy of <i>0.001</i>&nbsp; instead of the 
default accuracy. A different type of overwritten methods enables to provide an 
instance for the result, which helps to relieve the garbage collector. The call
</p>

<blockquote>

<p><tt><i>schottky.abelianDifferentialOf1stKind( r, z, n )</i></tt> </p>

</blockquote>

<p>evaluates <i> <font face="Symbol">w</font><sub>n</sub><font face="Symbol"><sup>
</sup></font></i>&nbsp;at <i>z</i> and returns the result in <i>r</i>, for example. </p>
<p></p>
<h2><a name="sec: theta"></a>de.jtem.riemann.theta </h2>
<p>This package implements the methods and algorithms presented in [<a href="#[Sch05]">Sch05</a>, 
Chapter 3] for computing riemann theta functions including those with 
characteristics. An important ingredient for the computation of Riemann theta 
function are modular transformations and Siegel�s Reduction algorithm for which 
the package also offers public interfaces.</p>
<p></p>
<h3><a NAME="SECTION00162100000000000000">Computing Riemann theta functions</a>
</h3>
<p>The Riemann theta function is a complex-valued function of <i>g</i> 
complex variables and defined by <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
\theta\left(z\left|B\right.\right)=\sum_{n\in\Z^{g}}{\displaystyle e^{\frac{1}{2}\left\langle n,B\cdot n\right\rangle +\left\langle z,n\right\rangle }},
\end{displaymath}
 -->
  <p>
  <img border="0" src="doc-files/index.10.gif" width="144" height="46">
</div>
<p>where <i>z<font face="Symbol">�</font>C<sup>g</sup></i> 
and <i>B</i> 
is a symmetric <i>g</i>-dimensional 
matrix with strictly negative definite real part. Be aware that there are many 
different conventions of writing the theta functions and that you therefore 
might have to perform a scaling of the arguments to adapt it to yours.
</p>
<p>The complex matrix <i>B</i> 
is usually the period matrix of a given Riemann surface and computing it is a 
hole different story. The Schottky uniformization as described in the previous 
Section offers one way of calculating it. </p>
<p>Suppose you have a valid period matrix <i>B</i>: 
To evaluate Riemann theta functions create an instance of the central class of 
this package: </p>

<blockquote>

<p><tt><i>theta = new Theta( B ).</i></tt> </p>

</blockquote>

<p>The period matrix is the most important property of the class <tt><i>Theta.</i></tt> 
You can change it by calling </p>

<blockquote>

<p><tt><i>theta.setPeriodMatrix( B ).</i></tt>&nbsp; </p>

</blockquote>

<p>This will trigger some pre-calculation steps. The implementation is optimized to 
evaluate the Riemann theta function many times for a fixed period matrix. Thus, 
setting the period matrix takes much longer then evaluating the function. 
Unfortunately, it is not possible to be more precise, because the expenditure 
depends on the period matrix (especially its genus) and the configuration of the 
evaluating instance. </p>

<blockquote>

<p><tt><i>Complex r = theta.theta( z )</i></tt>&nbsp; </p>

</blockquote>

<p>evaluates the Riemann theta function at the argument <i>z<font face="Symbol">�</font>C<sup>g</sup></i>. 
Following the philosophy of the whole project, there exist also overloaded 
methods which allow to prescribe the result as a parameter: </p>

<blockquote>

<p><tt><i>theta.theta( z, r ).</i></tt>&nbsp;
</p>

</blockquote>

<p>These functions are not particularly useful because the Riemann theta function 
grows exponentially and in practice you might easily leave the range of the 
double precession representation. It is therefore necessary to separate the 
exponential growth from the oscillating part of the function: <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
\theta\left(z\left|B\right.\right)=e^{f\left(z\left|B\right.\right)}\cdot\theta_{\Sigma}\left(z\left|B\right.\right)\,,
\end{displaymath}
 -->
  <p><img border="0" src="doc-files/index.11.gif" width="142" height="27">,</div>
<p>with
<!-- MATH
 $f\left(z\left|B\right.\right)$
 -->
<i>f(z|B)</i> 
being a quadratic function in <i>z</i>, 
see [<a href="#[Sch05]">Sch05</a>, Chapter 
3].</p>

<blockquote>

<p><tt><i>theta.theta( z, f, o )</i></tt>&nbsp;</p>

</blockquote>

<p>evaluates the Riemann theta function in the form from above with
<!-- MATH
 $f=f\left(z\left|B\right.\right)$
 -->
<i>f=f(z|B)</i> 
and <i>o=<font face="Symbol">q<sub>S</sub></font>(z|B)</i>. 
The accuracy of the evaluation always refers to the oscillating part <tt><i>o</i></tt> 
only and is by default <i>10<sup>-7</sup></i>. 
In almost all applications theta functions are used to compute Abelian functions, 
which can be expressed as ratios of theta functions. Thus, the exponential 
factors usually almost cancel. Typical examples are of the form: <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
f\left(z\right)=\frac{\theta\left(z+a\left|B\right.\right)}{\theta\left(z+b\left|B\right.\right)}=e^{f\left(z+a\left|B\right.\right)-f\left(z+b\left|B\right.\right)}\cdot\frac{\theta_{\Sigma}\left(z+a\left|B\right.\right)}{\theta_{\Sigma}\left(z+b\left|B\right.\right)}\,.
\end{displaymath}
 -->
  <p>
  <img border="0" src="doc-files/index.12.gif" width="286" height="47">
</div>
<p>Since the vectors
<!-- MATH
 $a,b\in\mathbb{C}^{g}$
 -->
<i>a,b<font face="Symbol">�</font>C<sup>g</sup></i> 
are relatively small the exponential factor is about <i>1</i>. An implementation of 
this function could look like:
</p>
<hr>
    
      <blockquote>
    
      <p>
      <tt>package helicoid.example;<br>
      <br>
      import mfc.field.Complex;<br>
      import blas.ComplexMatrix; <br>
      import blas.ComplexVector; <br>
      import riemann.theta.Theta;<br>
      <br>
      public class SimpleAbelianFunction {<br>
      <br>
&nbsp;&nbsp;&nbsp; ComplexMatrix B;<br>
&nbsp;&nbsp;&nbsp; ComplexVector a, b;<br>
&nbsp;&nbsp;&nbsp; Theta theta;<br>
      <br>
&nbsp;&nbsp;&nbsp; public SimpleAbelieanFunction( ComplexMatrix B,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ComplexVector&nbsp;a,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ComplexVector 
        b&nbsp;)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.B = new ComplexMatrix(B);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a = new ComplexVector(a);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.b = new ComplexVector(b);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theta=new Theta(B);<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp; public Complex valueAt( ComplexVector z ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theta.theta( z.plus(a), f_a, o_a );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theta.theta( z.plus(b), f_b, o_b );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Complex.exp( f_a.miuns(&nbsp;f_b&nbsp;)&nbsp;).times(&nbsp;o_a&nbsp;).divide(&nbsp;o_b&nbsp;);
      <br>
&nbsp;&nbsp;&nbsp; }<br>
      }</tt> </p>
    
    </blockquote>
    
<hr>
<p>The implementation is not optimal if the function needs to be evaluated many 
times, because it creates six unnecessary instances for intermediate results. 
This can be avoided by using the mutable programming style, see de.jtem.mfc.
</p>
<p>The API also offers functions for the first and second derivative of the 
theta function with respect to <i>z</i>.
</p>
<blockquote>
<p><tt><i>Complex r = dTheta.theta( z, X )</i></tt>&nbsp;
</p>
</blockquote>
<p>computes the partial derivative of theta in direction of <i>X</i>. 
Again this method is overloaded by a version that separates the exponential 
growth of the derivative from the oscillating part: <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
D_{X}\theta\left(z\left|B\right.\right)=e^{f\left(z\left|B\right.\right)}\cdot\left(D_{X}\theta\right)_{\Sigma}\left(z\left|B\right.\right)\,,
\end{displaymath}
 -->
  <p>
  <img border="0" src="doc-files/index.13.gif" width="193" height="27">
</div>
<p>with <i>f</i>&nbsp; 
being the same quadratic function as for the Riemann theta function itself.
</p>

<blockquote>

<p><tt><i>dTheta.theta( z, X, f, o, dxo )</i></tt> </p>

</blockquote>

<p>evaluates the function and the derivative simultaneously with&nbsp;
<!-- MATH
 $f=f\left(z\left|B\right.\right)$
 -->
<i>f=f(z|B)</i>, <i>o=<font face="Symbol">q<sub>S</sub></font>(z|B)</i><!-- MATH
 $f=f\left(z\left|B\right.\right)$
 -->, 
and <i>dxo=<font face="Symbol">(</font>D<sub>X</sub><font face="Symbol">q)<sub>S</sub></font>(z|B)</i>. 
Evaluating the function causes almost no extra cost and in many applications, 
e.g., logarithmic derivatives, you need the function value in addition to its 
derivative. Evaluating the second derivative works similar. </p>
<p>The error estimates for the derivative of the Riemann theta function are much 
more complicated than for the function itself. Therefore, we implemented the 
derivatives of the approximation instead of approximating the derivative. In 
almost 10 years experience in computing theta functions we never encountered any 
practical problems caused by inaccuracies of the derivatives, but in theory 
badly conditioned scenarios are likely to occur for large arguments <i>z</i>.
</p>
<p>There are three important boolean properties that configure the evaluation 
algorithm of the Riemann theta function: </p>
<p></p>
<ol>
  <li><tt>fillFactorErrorUsed</tt> </li>
  <li><tt>uniformApproximationUsed</tt> </li>
  <li><tt>siegelReductionPerformed</tt> </li>
</ol>
<p>By default all properties are set to <tt>true</tt>, but in certain situations 
different configurations may lead to better results. </p>
<p>The fill factor error (FFE) is a heuristic value to sharpen the error 
estimates for theta functions, which can drastically reduce the number of terms 
needed to approximate the oscillating part, see [<a href="http://www.amath.washington.edu/~bernard/papers/pdfs/computingtheta.pdf">DHB+04</a>] for details. The 
drawback of using the FFE is that the prescribed accuracy is not guaranteed 
anymore. Tests have shown that in practice the FFE is usually good enough. When 
accuracy is your concern rather than performance you might want to set this 
property to <tt>false</tt>. </p>
<p>The second property allow for the choice between uniform and pointwise 
approximation. For genus smaller than five uniform approximation is usually 
faster than pointwise. For higher genus pointwise approximation seems better, 
but that always depends on the specific case. The uniform approximation consumes 
some pre-calculation time, thus, if you only need to evaluate the theta function 
a few times for a fixed period matrix the pointwise approximation can also 
perform better for small genus. If performance is an important issue in your 
application you should try both possibilities; consult [<a href="#[Sch05]">Sch05</a>, Chapter 
3, Section 3.3] 
for a more complete discussion. </p>
<p>The last propertiy controls whether Siegel's reduction algorithm is performed 
when the period matrix is set. Switching it off is only sensible in situations 
where you already know that your period matrix is not reducible by Siegel's 
algorithm. But this will only have a significant impact if you have no more than 
a few function evaluations for a fixed period matrix. </p>
<p></p>
<p></p>
<h2><a name="sec: KP2 Equation"></a>Example: KP2 Equation - Shallow Water Waves</h2>
<p>We like to give an example implementation which 
combines the capabilities of the <tt><i>de.jtem.riemann.schottky</i></tt> and <tt><i>
de.jtem.riemann.theta</i></tt> packages. </p>
<p align="center">
<a href="http://www.math.tu-berlin.de/~schmies/java/webStart/research/KP/KP2.jnlp">
<img style="cursor: -moz-zoom-out" alt="http://www.math.tu-berlin.de/~schmies/java/webStart/research/KP/KP2.jpg" src="http://www.math.tu-berlin.de/~schmies/java/webStart/research/KP/KP2.jpg" width="400" height="403"></a></p>

  

      <blockquote>
        <blockquote>
          <blockquote>

  

      <p align="center"><strong>Figure:</strong> Snap-shot of a webstart 
      application visualizing shallow water waves computed as solutions of the 
      KP2 equation using Schottky uniformization as described above. The 
      application was generated using <i><a href="http://www.oorange.de/">Java Oorange</a></i>. 
      The 3D-graphics utilizes <a href="http://www.jreality.de">jReality</a>. This 
and other applications using the jtem library can be downloaded from
      <i><a href="http://www.math.tu-berlin.de/geometrie/lab/">http://www.math.tu-berlin.de/geometrie/lab/</a></i> 
. <br>
      <b>To start the java webstart application click onto the image.</b></p>
    
  

          </blockquote>
        </blockquote>
</blockquote>
<p>The equations <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
4u_{xt}+3\left(u^{2}\right)_{xx}\pm u_{xxxx}-3u_{yy}=0
\end{displaymath}
 -->
</div>
<p align="center"><i>4u</i><sub>xt</sub><i> + 3(u<sup>2</sup>)</i><sub>xx</sub><i> &plusmn; u</i><sub>xxxx</sub><i> 
- 3u</i><sub>yy</sub><i> = 0</i></p>
<p></p>
<p>discovered by Kadomtsev &amp; Petviashvili (KP) are a generalization of the 
Korteweg &amp; deVries (KdV) 
equation. For positive sign of the <i>u</i><sub>xxxx</sub> 
term it is called KP2 equation. Solutions of the KP2 equation describe the 
evolution of gravity-induced waves of moderate amplitude on shallow water of 
uniform depth when the waves are nearly one-dimensional.</p>
<p>For Schottky data <br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
S=\left\{ A_{1},B_{1},\mu_{1},\ldots,A_{N},B_{N},\mu_{N}\right\}
\end{displaymath}
 -->
  <p>
  S = { <i>A<sub>1</sub>, B<sub>1</sub>,<font face="Symbol"> 
  m</font><sub>1</sub><font face="Symbol"><sub>, ... , </sub></font>A<sub>N</sub> B<sub>N</sub>,<font face="Symbol"> 
  m</font><sub>N</sub></i><font face="Symbol"><sub> </sub></font>}
</div>
<p><br CLEAR="ALL">
</p>
<p></p>
<p>with
<!-- MATH
 $B_{i}=\bar{A_{i}}$
 -->
B<sub>i</sub>=A<sub>i</sub> 
and&nbsp; <i><font face="Symbol"> 
  m</font></i><sub>i</sub><font face="Symbol">�</font><b>R</b> yield all real 
non-singular finite-gap solutions of the KP2 equation and can be described by 
Krichever's formula<br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
u\left(x,y,t\right)=2\frac{\partial^{2}}{\partial x^{2}}\log\theta\left(U\, x+V\, y+W\, t+D\left|B\right.\right)+2c\,,
\end{displaymath}
 -->
  <p>
  <img border="0" src="doc-files/index.15.gif" width="285" height="41"></div>
<p>The parameters in this formula can be given by 
Poincare series. It is</p>
<p><i>U=V<sub>n,1</sub>, V=V<sub>n,2</sub>, </i>and<i>&nbsp; W=V<sub>n,3 </sub>&nbsp;with
</i>
</p>
<p align="center"><span style="position: relative; top: 16.0pt">
<img border="0" src="doc-files/index.18.gif" width="186" height="37"></span></p>
<p align="center">and</p>
<p align="center"><img border="0" src="doc-files/index.16.gif" width="88" height="42"><br>
</p>
<p></p>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
\begin{array}{rcccl}
U & = & V_{n,1} & = & \sum_{\sigma\in\GnG}\sigma\left(A_{n}\right)-\sigma\left(B_{n}\right)\,,\\
V & = & V_{n,2} & = & \sum_{\sigma\in\GnG}\sigma\left(A_{n}\right)^{2}-\sigma\left(B_{n}\right)^{2}\,,\\
W & = & V_{n,3} & = & \sum_{\sigma\in\GnG}\sigma\left(A_{n}\right)^{3}-\sigma\left(B_{n}\right)^{3}\,,\end{array}
\end{displaymath}
 -->
</div>
<div ALIGN="CENTER">
  <!-- MATH
 \begin{displaymath}
\begin{array}{rcccc}
c & = & \gamma & = & \sum_{\sigma\in G}\frac{1}{\gamma_{\sigma}^{2}}\end{array}
\end{displaymath}
 -->
</div>
<p>and D is an arbitrary imaginary vector [<a href="#[BBE+94]">BBE+94</a>] .</p>
<p>The code below shows an implementation of this solution using the efficient 
mutable programming style, see <font face="Courier"><i>de.jtem.mfc</i></font> .</p>
<hr>
    
      <p>
      <tt>package de.jtem.riemann.example;<br>
      <br>
      import mfc.field.Complex; <br>
      import riemann.schottky.*; <br>
      import riemann.theta.*;<br>
      import blas.*;<br>
      <br>
      public class KP2 {<br>
      <br>
&nbsp;&nbsp;&nbsp; Schottky schottky; <br>
&nbsp;&nbsp;&nbsp; Theta theta;<br>
&nbsp;&nbsp;&nbsp; ComplexVector U, V, W, Z, T; <br>
&nbsp;&nbsp;&nbsp; Complex c;<br>
      <br>
&nbsp;&nbsp;&nbsp; public KP2( Complex [] A, double [] mu, double eps ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SchottkyData data = new SchottkyData( A.length 
          );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i=0; i&lt;A.length; i++ ) {
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.setA( i, A[i] );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.setB( i, A[i].conjugate() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.setMu( i, mu[i], 0 );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !schottkyData.isClassical() )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new IllegalArgumentException<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&quot;schottky&nbsp;data&nbsp;is&nbsp;not&nbsp;classical&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schottky = new Schottky( schottkyData, eps );<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !schottky.isSeriesEvaluable() )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new IllegalArgumentException(&nbsp;&quot;can&nbsp;not&nbsp;evaluate&nbsp;series&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U = schottky.getV();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V = schottky.getV(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W = schottky.getV(3);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = schottky.gamma();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = new ComplexVector( U.size() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T = new ComplexVector( U.size() );<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Theta theta&nbsp;=&nbsp;new&nbsp;Theta(&nbsp;schottky.getPeriodMatrix(),&nbsp;eps&nbsp;);<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp; public Complex valueAt( double x, double y, 
        double t ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z.assignTimes( U, x );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T.assignTimes( V, y ); Z.assignPlus( T );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T.assignTimes( W, t ); Z.assignPlus( T );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Complex result = theta.ddLogTheta( Z, U, U );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.assignPlus(c);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.assignTimes(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
&nbsp;&nbsp;&nbsp; }<br>
      } </tt></p>
    
<hr>
<h2>Bibliography</h2>
<p><a name="[BBE+94]"></a>[BBE+94]&nbsp;&nbsp;&nbsp; E.D. Belokolos, A. I. 
Bobenko, V. Z. Enol'skii, A. R. Its, and V. B. Matveev. Algebro-<i>Geometric 
Approach to Nonlinear Integrable Equations</i>. Nonlinear Dynamics. Springer 
Verlag, 1994.</p>
<p><a name="[DHB+04]"></a>[DHB+04]&nbsp;&nbsp; B. Deconinck, M. Heil, A. I. 
Bobenko, M. van Hoeij, and M. Schmies. Comput Riemann theta Functions. Math. 
Comp., 73(247):1417-1442 (electronic) 2004.&nbsp;&nbsp;&nbsp; (.pdf)</p>
<p><a name="[Dub81]"></a>[Dub81]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B. A. 
Dubrovin. Theta functions and non-linear equations. Russ. Math. Surv., 
36(2):11-92, 1981.&nbsp;&nbsp;&nbsp; </p>
<p><a name="[Kri78]"></a>[Kri78]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I. M. 
Krichever. Algebraic curves and non-linear difference equations. Russ. Math. 
surv., 33(4):255-256, 1978.</p>
<p><a name="[Sch05]"></a>[Sch05]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M. 
Schmies. Computational Methods for Riemann Surfaces and Helicoids with Handles. 
PhD thesis, Technische Universit�t Berlin, 2005.&nbsp;&nbsp;&nbsp; (<a href="http://opus.kobv.de/tuberlin/volltexte/2005/1105/pdf/schmies_markus.pdf">.pdf</a>)</p>
<address>
  Markus Schmies 2006-01-14
</address>

</body>

</html>
